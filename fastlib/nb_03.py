
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/03_datablock_image_loading.ipynb

from fastlib.nb_02 import *

# adding .ls monkey patch to pathlib Path
from pathlib import Path
Path.ls = lambda x: list(x.iterdir())

import PIL, os, mimetypes

image_extensions = set([k for k,v in mimetypes.types_map.items() if v.startswith('image/')])

def setify(o): return o if isinstance(o, set) else set(listify(o))

def _get_files(p, fnames, extensions=None):
    """
    filters `fnames`  the files in a `specific directory` p with `specific extensions` extensions
    p: path of the directory
    fnames:
    """
    p = Path(p)
    res = [p/f for f in fnames if not f.startswith(".")
           and ((not extensions) or f'.{f.split(".")[-1].lower()}' in extensions)]
    return res

def get_files(p, extentions=None, recurse=False, include=None):
    path = Path(p)
    extensions = setify(extentions)
    extensions = {e.lower() for e in extensions}
    if recurse:
        res = []
        for p,d,f in os.walk(path):
            if include is not None: d[:] = [o for o in d if o in include]
            else:
                d[:] = [o for o in d if not o.startswith(".")]
                res += _get_files(p, f, extensions)
        return res
    else:
        f = [o.name for o in os.scandir(path) if o.is_file()]
        return _get_files(path, f, extensions)

def compose(x, funcs, *args, order_key="_order", **kwargs):
    key = lambda o: getattr(o, order_key, 0)
    for f in sorted(listify(funcs), key=key): x = f(x, **kwargs)
    return x

class ItemList(ListContainer):

    def __init__(self, items, path=".", tfms=None):
        super().__init__(items)
        self.path, self.tfms = Path(path), tfms

    def __repr__(self): return f'{super().__repr__()} \n\nPath: {self.path}'
    def new(self, items): return self.__class__(items, self.path, tfms=self.tfms)

    ##children override the get method
    def get(self, i): return i
    def _get(self, i): return compose(self.get(i), self.tfms)

    def __getitem__(self, idx):
        res = super().__getitem__(idx)
        if isinstance(res, list): return [self._get(o) for o in res]
        return self._get(res)

class ImageList(ItemList):

    @classmethod
    def from_files(cls, path, extensions=None, recurse=True, include=None, **kwargs):
        if extensions is None: extensions = image_extensions
        return cls(get_files(path, extentions=extensions, recurse=recurse, include=include), path, **kwargs)

    def get(self, fn): return PIL.Image.open(fn)

class Transform(): _order=0

class MakeRGB(Transform):
    def __call__(self, item):
        return item.convert('RGB')

def grand_parent_splitter(fns, valid_name="valid", train_name="train"):
    gp = fns.parent.parent.name
    return True if gp==valid_name else False if gp==train_name else None

def split_by_func(ds, f):
    items = ds.items
    masks = [f(item) for item in items]
    train = [item for item, mask in zip(items, masks) if mask==False]
    valid = [item for item, mask in zip(items, masks) if mask==True]
    return train, valid

class SplitData():

    def __init__(self, train, valid): self.train, self.valid = train, valid

    @classmethod
    def split_by_func(cls, il, f):
        lists = map(il.new, split_by_func(il, f))
        return cls(*lists)

    def __repr__(self):
        return f"{self.__class__.__name__} \nTrain: {self.train}  \nValid: {self.valid}"

from collections import OrderedDict

def uniqueify(x, sort=False):
    res = list(OrderedDict.fromkeys(x).keys())
    if sort: res.sort()
    return res

class Processor():
    def process(self, items): return items

class CategoryProcessor(Processor):

    def __init__(self): self.vocab = None

    def process(self, items):

        if self.vocab is None:
            self.vocab = uniqueify(items)
            self.otoi = {v:k for k,v in enumerate(self.vocab)}

        return [self.proc1(item) for item in items]

    def proc1(self, item):
        return self.otoi[item]

    def deprocess(self, idxs):
        assert self.vocab is not None
        return [self.deproc1(idx) for idx in idxs]

    def deproc1(self, idx):
        return self.vocab[idx]


class ProcessedItemList(ListContainer):

    def __init__(self, inputs, processor):
        self.processor = processor
        items = self.processor.process(inputs)
        super().__init__(items)

    def obj(self, idx):
        res = self[idx]
        if isinstance(res,(tuple,list,Generator)): return self.processor.deprocess(res)
        return self.processor.deproc1(res)

def _label_by_func(il, f):
    return [f(item) for item in il.items]

class LabeledData():

    def __init__(self, x,y): self.x, self.y = x,y

    def __len__(self): return len(self.x)
    def __getitem__(self, idx): return self.x[idx], self.y[idx]
    def __repr__(self): return f"{self.__class__.__name__} \nx: {self.x} \ny: {self.y}"


    @classmethod
    def label_by_func(cls, il, f, proc=None):
        labels = _label_by_func(il, f)
        proc_labels = ProcessedItemList(labels, proc)
        return cls(il, proc_labels)

def label_by_func(sd, f):
    proc = CategoryProcessor()
    train = LabeledData.label_by_func(sd.train, f, proc)
    valid = LabeledData.label_by_func(sd.valid, f, proc)
    return SplitData(train, valid)

def parent_labeller(fn): return fn.parent.name

class ResizeTransform(Transform):
    _order = 10

    def __init__(self, size):
        if isinstance(size, int): size = (size,size)
        self.size = size

    def __call__(self, item):
        return item.resize(self.size, PIL.Image.BILINEAR)


class ByteTesorTransform(Transform):

    _order = 20
    def __call__(self, item):
        res = torch.ByteTensor(torch.ByteStorage.from_buffer(item.tobytes()))
        w,h = item.size
        return res.view(h,w,-1).permute(2,0,1)

class FloatTensorTransform(Transform):

    _order = 30
    def __call__(self, item):
        return item.float().div_(255.)

def show_image(im, figsize=(3,3)):
    plt.figure(figsize=figsize)
    plt.axis('off')
    plt.imshow(im.permute(1,2,0))

class DataBunch():
    def __init__(self, train_dl, valid_dl, c_in=None, c_out=None):
        self.train_dl,self.valid_dl,self.c_in,self.c_out = train_dl,valid_dl,c_in,c_out

    @property
    def train_ds(self): return self.train_dl.dataset

    @property
    def valid_ds(self): return self.valid_dl.dataset

def databunchify(sd, bs, c_in=None, c_out=None, **kwargs):
    dls = get_dls(sd.train, sd.valid, bs, **kwargs)
    return DataBunch(*dls, c_in=c_in, c_out=c_out)

SplitData.to_databunch = databunchify